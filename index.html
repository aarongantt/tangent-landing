<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Tangent – Join the Waitlist</title>
    <meta name="description" content="AI that meets you where your attention already is.">
    <link rel="icon" type="image/png" href="images/tangent_t_logo.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: url('images/tangent_wave_bg.png') center center / cover no-repeat fixed;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
        }

        html {
            height: -webkit-fill-available;
        }

        /* Main text container */
        #main-text {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            white-space: nowrap;
            z-index: 10;
            transition: top 0.6s ease-out, font-size 0.6s ease-out;
        }

        #main-text.shifted-up {
            top: 40px;
            font-size: 40.8px;
        }

        #main-text span {
            position: relative;
            color: #ffffff;
        }

        /* Highlight effect - slides left to right */
        #main-text span.highlighted::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            background: #6eb6fe;
            border-radius: 0px;
            z-index: -1;
        }

        #main-text span.highlighted.active {
            color: #FFFFFF;
        }

        /* Animated Cursor */
        .demo-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 300;
            display: none;
            transition: left 0.5s ease-out,
                        top 0.5s ease-out,
                        opacity 0.3s ease-out;
        }

        .demo-cursor img {
            width: 40px;
            height: auto;
            display: block;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        /* Chip Bar - 1.5x larger (for main intro section) */
        .chip-bar {
            position: absolute;
            z-index: 100;
            display: none;
            gap: 9px;
            padding: 9px 21px;
            background: linear-gradient(
                to bottom,
                #dce4ea 0%,
                #c4ced6 100%
            );
            border: 3px solid rgba(109, 109, 109, 0.494);
            border-radius: 21px;
            box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease, top 0.6s ease-out;
        }

        /* Chip bar scaled down when panel expands */
        .chip-bar.scaled-down {
            transform: scale(0.75) translateY(-30px);  /* 25% reduction + move up 30px */
            transition: opacity 0.3s ease, transform 0.6s ease-out, top 0.6s ease-out;
        }

        .chip-bar.scaled-down.visible {
            transform: scale(0.75) translateY(-30px);
        }

        /* Demo Chip Bar - scaled for 3-column layout */
        .demo-section .chip-bar {
            gap: 6px;
            padding: 6px 14px;
            border: 2px solid rgba(109, 109, 109, 0.494);
            border-radius: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        }

        .chip-bar.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .chip-bar.initial-state {
            display: flex;
            align-items: center;
        }

        .chip-bar.email-state {
            display: flex;
            align-items: center;
            padding: 9px 21px;
        }

        /* Demo email state override */
        .demo-section .chip-bar.email-state {
            padding: 6px 14px;
        }

        /* Chip Bar - Initial State Elements - 1.5x larger (for main intro) */
        .chip {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, sans-serif;
            font-weight: 600;
            font-size: 1.5em;
            line-height: 1.2;
            padding: 9px 15px;
            border-radius: 999px;
            border: 3px solid rgba(109, 109, 109, 0.494);
            background: rgba(255, 255, 255, 1);
            color: #111;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease, transform 0.08s ease;
        }

        /* Demo chips - scaled for 3-column layout */
        .demo-section .chip {
            font-size: 1em;
            padding: 6px 10px;
            border: 2px solid rgba(109, 109, 109, 0.494);
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.96);
        }

        .chip:active {
            transform: translateY(0.6px);
        }

        .demo-section .chip:active {
            transform: translateY(0.4px);
        }

        .chip-icon {
            padding: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 48px;
            border-radius: 9px;
        }

        .demo-section .chip-icon {
            padding: 6px;
            min-width: 32px;
            border-radius: 6px;
        }

        .chip-icon img {
            width: 27px;
            height: 27px;
            display: block;
        }

        .demo-section .chip-icon img {
            width: 18px;
            height: 18px;
        }

        .chevron-chip {
            padding: 7.65px;
            position: relative;
            min-width: 40.8px;
            min-height: 40.8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .demo-section .chevron-chip {
            padding: 3px 5px 2px 5px;
            min-width: 27px;
            min-height: 18px;
        }

        .chevron-chip img {
            width: 22.95px;
            height: 22.95px;
            display: block;
            margin: auto;
        }

        .demo-section .chevron-chip img {
            width: 15px;
            height: 8px;
        }

        /* Email Input State - 1.5x larger (for main intro) */
        .email-container {
            display: none;
            flex: 1;
            align-items: center;
            gap: 12px;
            position: relative;
        }

        .demo-section .email-container {
            gap: 8px;
        }

        .email-input {
            width: 100%;
            padding: 15px 54px 15px 18px;
            border-radius: 33px;
            border: 2.25px solid #787878;
            background: rgba(255, 255, 255, 1);
            color: #1f2937;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, sans-serif;
            font-size: 21px;
            outline: none;
            min-width: 450px;
        }

        .demo-section .email-input {
            padding: 10px 36px 10px 12px;
            border-radius: 22px;
            border: 2px solid #787878;
            font-size: 14px;
            min-width: 280px;
        }

        .email-input:focus {
            border-color: #669fc3;
            box-shadow: 0 0 6px 1px rgba(102, 159, 195, 0.25),
                        0 0 12px 2px rgba(102, 159, 195, 0.2);
        }

        .demo-section .email-input:focus {
            box-shadow: 0 0 4px 1px rgba(102, 159, 195, 0.25),
                        0 0 8px 1px rgba(102, 159, 195, 0.2);
        }

        .email-input::placeholder {
            color: #9aa3b2;
            font-style: italic;
            font-size: 19.5px;
        }

        .demo-section .email-input::placeholder {
            font-size: 13px;
        }

        .send-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 2.5px solid #787878;
            background: #ffffff;
            color: #2a8fd5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s ease, transform 0.08s ease;
            padding: 0;
            box-shadow: 0 1.2px 4.8px rgba(0, 0, 0, 0.1);
        }

        .demo-section .send-btn {
            right: 7px;
            width: 28px;
            height: 28px;
            border: 2px solid #787878;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .send-btn:hover {
            background: #f5f5f5;
            border-color: #4895db;
        }

        .send-btn:active {
            transform: translateY(-50%) scale(0.95);
            border-color: #4895db;
        }

        .send-btn img {
            width: 21px;
            height: 21px;
            display: block;
            transition: opacity 0.15s ease;
        }

        .demo-section .send-btn img {
            width: 14px;
            height: 14px;
        }

        .send-btn img.default {
            opacity: 1;
        }

        .send-btn img.hover {
            position: absolute;
            opacity: 0;
        }

        .send-btn:hover img.default {
            opacity: 0;
        }

        .send-btn:hover img.hover {
            opacity: 1;
        }

        /* Tangent Panel - EXACT match to mockup */
        #tangent-panel {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            z-index: 50;
            opacity: 0;
            transition: transform 0.6s ease-out, opacity 0.6s ease-out;
            cursor: pointer;

            width: 1800px;
            max-width: calc(100vw - 200px);
            height: 900px;
            overflow: visible;

            background: linear-gradient(
                to bottom,
                #c8d4dc 0%,
                #a0b0bc 100%
            );

            box-shadow:
                inset 0 3px 0 0 rgba(255, 255, 255, 0.6),
                0 -12px 48px rgba(0, 0, 0, 0.35),
                -4px 0 12px rgba(0, 0, 0, 0.2),
                4px 0 12px rgba(0, 0, 0, 0.2);

            border-radius: 32px 32px 0 0;
            border: 5px solid rgba(180, 180, 180, 0.7);
            border-bottom: none;

            display: flex;
            flex-direction: column;

            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, sans-serif;
        }

        #tangent-panel.visible {
            transform: translateX(-50%) translateY(calc(100% - 275px));
            opacity: 1;
        }

        #tangent-panel.visible:hover:not(.expanded) {
            transform: translateX(-50%) translateY(calc(100% - 315px));
        }

        #tangent-panel.expanded {
            transform: translateX(-50%) translateY(5%);
            cursor: default;
            z-index: 150;
        }

        .tangent-panel__header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 50px 80px;
            flex-shrink: 0;
            background: transparent;
            transition: padding 0.6s ease-out, transform 0.6s ease-out;
        }

        #tangent-panel.expanded .tangent-panel__header {
            padding: 40px 64px;
            transform: scale(0.8);
        }

        .tangent-pin {
            position: absolute !important;
            left: 60px !important;
            top: 50px !important;
            transform: none !important;

            width: 96px;
            height: 96px;
            padding: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.6;
            transition: none;
        }

        .tangent-pin img {
            width: 77px;
            height: 77px;
            display: block;
            filter: grayscale(100%) brightness(0.5);
        }

        .tangent-header-logo {
            height: 159px;  /* Full size when collapsed */
            width: auto;
            display: block;
            transition: height 0.6s ease-out;
        }

        #tangent-panel.expanded .tangent-header-logo {
            height: 140px;  /* Larger size when expanded for better visibility */
        }

        .tangent-panel__btns {
            position: absolute;
            right: 60px;
            top: 50px;
            transform: none;
            display: inline-flex;
            gap: 40px;
            align-items: center;
            transition: none;
        }

        .tangent-panel__btns > button {
            width: 72px;
            height: 72px;
            padding: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .tangent-panel__btns > button img {
            width: 58px;
            height: 58px;
            filter: grayscale(100%) brightness(0.4);
        }

        /* Tutorial Content (hidden until panel expands) */
        .tutorial-content {
            padding: 0px 80px 60px;  /* Remove top padding to bring step images up */
            overflow-y: auto;
            overflow-x: visible;
            flex: 1;
        }

        .tutorial-content::-webkit-scrollbar {
            width: 8px;
        }

        .tutorial-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .tutorial-content::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .tutorial-content::-webkit-scrollbar-thumb:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .tutorial-content {
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
        }

        /* Step indicators - 3 images in a row */
        .step-indicators {
            display: flex;
            justify-content: space-evenly;  /* Automatically distributes space evenly - fully dynamic! */
            align-items: center;
            margin-top: 20px;
            margin-bottom: 30px;
            padding: 0 20px;  /* Prevent icons from touching edges on narrow screens */
        }

        .step-indicators img {
            height: auto;
            max-height: clamp(45px, 5.5vw, 69px);  /* Flexible size: 45px min, 69px max, scales with viewport */
            width: auto;
            object-fit: contain;
            transition: filter 0.3s ease, max-height 0.3s ease, opacity 0.4s ease;
        }

        /* No glow effect on step icons */
        .step-indicators img.active {
            /* Glow removed per user request */
        }

        /* Move cursor only on panel header hover */
        #interactive-panel-header:hover {
            cursor: move;
        }

        /* Three-dot menu hover effect */
        .tangent-menu-toggle:hover {
            opacity: 1 !important;
        }

        /* Demo sections - 3 columns side by side */
        .demo-sections-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            margin-bottom: 60px;
        }

        .demo-section {
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .demo-section h3 {
            font-size: 1em;
            margin-bottom: 20px;
            color: #2a2a2a;
            text-align: center;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .demo-section-content {
            position: relative;
            min-height: 300px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            flex: 1;
        }

        /* Demo text (for step 1 and 2) - smaller for 3-column layout */
        .demo-text {
            font-size: 18px;
            font-weight: bold;
            color: #1a1a1a;
            text-align: center;
            position: relative;
            line-height: 1.4;
        }

        .demo-text span {
            position: relative;
            color: #1a1a1a;
        }

        .demo-text span.highlighted::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            background: #6eb6fe;
            border-radius: 0px;
            z-index: -1;
        }

        /* Tangent Chat Panel (for step 3) - smaller for 3-column layout */
        .tangent-chat-panel {
            width: 100%;
            max-width: 380px;
            height: 380px;
            background: linear-gradient(
                to bottom,
                #c8d4dc 0%,
                #a0b0bc 100%
            );
            border-radius: 12px;
            border: 2px solid rgba(109, 109, 109, 0.494);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            display: flex;
            flex-direction: column;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, sans-serif;
            position: relative;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        .tangent-chat-panel.visible {
            opacity: 1;
            transform: scale(1);
        }

        .tangent-chat-header {
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid rgba(109, 109, 109, 0.2);
        }

        .tangent-chat-header img {
            height: 40px;
            width: auto;
        }

        .tangent-chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tangent-chat-body::-webkit-scrollbar,
        #interactive-chat-body::-webkit-scrollbar {
            width: 12px;
        }

        .tangent-chat-body::-webkit-scrollbar-track,
        #interactive-chat-body::-webkit-scrollbar-track {
            background: transparent;
            margin-right: 4px;
        }

        .tangent-chat-body::-webkit-scrollbar-thumb,
        #interactive-chat-body::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            border-right: 4px solid transparent;
            background-clip: padding-box;
        }

        /* Minimized panel state - hide everything except header */
        #interactive-tangent-panel.minimized #interactive-chat-body,
        #interactive-tangent-panel.minimized > div > div:nth-child(2),
        #interactive-tangent-panel.minimized > div > div:nth-child(3) {
            display: none !important;
        }

        #interactive-tangent-panel.minimized {
            overflow: visible !important;  /* Allow header to show fully */
        }

        .tg-msg {
            margin-bottom: 16px;
            font-size: 14px;
            line-height: 1.6;
        }

        .tg-msg.tg-user {
            display: flex;
            justify-content: flex-end;
        }

        .tg-msg.tg-user .tg-user__bubble {
            background: rgb(46, 50, 59);
            color: #7f95b6;
            padding: 10px 14px;
            border-radius: 12px;
            display: inline-block;
            max-width: 80%;
        }

        .tg-msg.tg-ai {
            display: flex;
            justify-content: flex-start;
        }

        .tg-msg.tg-ai .tg-ai__content {
            padding: 10px 0;
            color: #2a2a2a;
            max-width: 100%;
        }

        .tg-msg.tg-ai .tg-ai__content p {
            margin: 0 0 12px 0;
        }

        .tg-msg.tg-ai .tg-ai__content p:last-child {
            margin-bottom: 0;
        }

        .thinking {
            color: #6b7280;
            font-style: italic;
        }

        .tangent-chat-input-container {
            padding: 16px 20px;
            border-top: 2px solid rgba(109, 109, 109, 0.2);
            position: relative;
        }

        .tangent-chat-input {
            width: 100%;
            padding: 12px 48px 12px 16px;
            border-radius: 24px;
            border: 2px solid #787878;
            background: rgba(255, 255, 255, 1);
            color: #1f2937;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, sans-serif;
            font-size: 14px;
            outline: none;
        }

        .tangent-chat-input:focus {
            border-color: #669fc3;
            box-shadow: 0 0 4px 1px rgba(102, 159, 195, 0.25);
        }

        .tangent-chat-send {
            position: absolute;
            right: 28px;
            top: 50%;
            transform: translateY(-50%);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #787878;
            background: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .tangent-chat-send img {
            width: 16px;
            height: 16px;
        }

        /* Success Modal */
        #success-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 400;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #success-modal.visible {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background: linear-gradient(
                to bottom,
                #c8d4dc 0%,
                #a0b0bc 100%
            );

            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);

            border-radius: 16px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            position: relative;

            box-shadow:
                inset 0 2px 0 0 rgba(255, 255, 255, 0.6),
                0 20px 60px rgba(0, 0, 0, 0.4),
                -4px 0 12px rgba(0, 0, 0, 0.2),
                4px 0 12px rgba(0, 0, 0, 0.2);

            border: 5px solid rgba(180, 180, 180, 0.7);

            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        #success-modal.visible .modal-content {
            transform: scale(1);
        }

        .modal-logo {
            width: 259px;
            height: auto;
            margin: 0 auto 30px;
            display: block;
        }

        .modal-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            font-size: 28px;
            color: rgba(0, 0, 0, 0.4);
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.15s ease;
        }

        .modal-close-btn:hover {
            color: rgba(0, 0, 0, 0.6);
        }

        .modal-content h2 {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #0f141a;
        }

        .modal-content p {
            font-size: 17px;
            line-height: 1.6;
            color: #0f141a;
            margin-bottom: 16px;
        }

        .modal-content p.modal-subtitle {
            font-size: 16px;
            font-style: italic;
        }

        .modal-content p:last-child {
            margin-bottom: 0;
        }

        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(46, 50, 59, 0.95);
            color: #e9eef5;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Inter, sans-serif;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 500;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            pointer-events: none;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Demo highlight text animation - letter by letter */
        #demo-highlight-text.highlighting::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            background: #6eb6fe;
            border-radius: 2px;
            z-index: -1;
        }
    </style>
</head>
<body>
    <!-- Main Text -->
    <div id="main-text">
        Stay in the flow, or go on a <span id="highlight-text">Tangent</span>.
    </div>

    <!-- Animated Cursor (for main intro) -->
    <div id="demo-cursor" class="demo-cursor">
        <img id="cursor-img" src="images/i_beam.png" alt="">
    </div>

    <!-- Chip Bar (for main intro) -->
    <div id="chip-bar" class="chip-bar initial-state">
        <!-- Initial State: Chips -->
        <div id="chips-container" style="display: flex; gap: 9px; align-items: center;">
            <button class="chip chip-icon" id="t-chip">
                <img src="images/tangent_t_logo.png" alt="T">
            </button>
            <button class="chip">What is...</button>
            <button class="chip">Context</button>
            <button class="chip">Summarize</button>
            <button class="chip chip-icon chevron-chip" id="chevron-chip">
                <img src="images/chevron_down_arrow.png" alt="More">
            </button>
        </div>

        <!-- Email State: T Icon + Email Input + Send Button -->
        <div id="email-container" class="email-container">
            <button class="chip chip-icon" id="t-chip-email" style="flex-shrink: 0;">
                <img src="images/tangent_t_logo.png" alt="T">
            </button>
            <input type="email" id="email-input" class="email-input" placeholder="Email for early access to Tangent.">
            <button id="send-btn" class="send-btn">
                <img src="images/tangent_enter_button.png" class="default" alt="Send">
                <img src="images/tangent_enter_button_blue.png" class="hover" alt="Send">
            </button>
        </div>
    </div>

    <!-- Tangent Panel (rises from bottom) -->
    <div id="tangent-panel">
        <!-- Pin Button (left) -->
        <button class="tangent-pin" title="Pin panel">
            <img src="images/pin_icon.png" alt="Pin">
        </button>

        <!-- Header Buttons (right) -->
        <div class="tangent-panel__btns">
            <button title="Minimize">
                <img src="images/minimize_icon.png" alt="Minimize">
            </button>
            <button title="Close">
                <img src="images/close_icon.png" alt="Close">
            </button>
        </div>

        <!-- Panel Header -->
        <div class="tangent-panel__header">
            <!-- Logo (center) -->
            <img src="images/tangent_logo_waitlist.png" alt="TANGENT" class="tangent-header-logo">
        </div>

        <!-- Tutorial Content (hidden until panel expands) -->
        <div class="tutorial-content" style="display: none; position: relative; height: 100%; overflow: hidden;">
            <!-- Step indicators (3 images in a row) -->
            <div class="step-indicators">
                <img id="step-indicator-1" src="images/step_01.png" alt="Step 1">
                <img id="step-indicator-2" src="images/step_02.png" alt="Step 2">
                <img id="step-indicator-3" src="images/step_03.png" alt="Step 3">
            </div>

            <!-- Scrollable demo area -->
            <div id="demo-scroll-area" style="position: relative; height: calc(100% - 60px); overflow-y: scroll; overflow-x: hidden; padding: 0 80px; scrollbar-width: none; -ms-overflow-style: none;">
                <style>
                    #demo-scroll-area::-webkit-scrollbar {
                        display: none;
                    }
                </style>

                <!-- Article content (large text block) -->
                <div id="demo-content-container" style="max-width: 900px; margin: 0 auto; padding: 120px 0 120px 0; position: relative;">
                    <p style="font-size: 32px; line-height: 1.8; color: #4b5563; text-align: justify; margin-bottom: 40px; font-weight: 400;">
                        In practice, progress is driven less by speed than by continuity—the ability to remain oriented within a developing line of thought while integrating new information without losing one's place. Knowledge work advances not because individual steps are efficient in isolation, but because each step remains coherently connected to the last. This coherence depends on a fragile internal structure: a working mental model that keeps track of what question is being addressed, what assumptions are active, what has already been established, and why the current passage matters. When this structure holds, complexity feels navigable. When it degrades, even simple material can feel resistant.
                    </p>

                    <p style="font-size: 32px; line-height: 1.8; color: #4b5563; text-align: justify; margin-bottom: 40px; font-weight: 400;">
                        Disruptions to this process rarely come from lack of intelligence or motivation. More often, they arise from small gaps in context: an unfamiliar term, an implicit reference, or an assumption left unstated by the author. These gaps are minor in absolute terms, but they introduce local uncertainty that the reader cannot simply ignore. Progress pauses not because the reader has disengaged, but because coherence has been compromised.
                    </p>

                    <p style="font-size: 32px; line-height: 1.8; color: #4b5563; text-align: justify; margin-bottom: 40px; font-weight: 400;">
                        <span id="demo-highlight-text" style="position: relative; display: inline;">Subtle cognitive cost</span> appears at precisely this moment. The standard response is to leave the page in search of clarification. In isolation, this is rational and often necessary. But at the level of sustained thought, each departure fragments attention and imposes a hidden tax. The reader must suspend the current line of reasoning, shift into a different informational frame, acquire the missing detail, and then return to the original material. What follows is not a clean continuation but an act of reconstruction: rebuilding the internal state that made the work intelligible in the first place.
                    </p>

                    <p id="tangent-paragraph" style="font-size: 32px; line-height: 1.8; color: #4b5563; text-align: justify; margin-bottom: 40px; font-weight: 400;">
                        That reconstruction involves reassembling several things at once: what was being argued or explored, why it mattered, how far the thinking had progressed, where the new information belongs. The deeper and more intricate the original mental model, the more expensive this reconstruction becomes. Importantly, the cost is nonlinear. A series of small interruptions can be more damaging than a single large one, because each switch partially collapses the internal structure that supports continuity. Over time, this erosion manifests as declining momentum, weakened confidence in the thread, and a growing sense that the work is heavier than it should be.

This state is often mistaken for fatigue or loss of interest. In reality, it is a structural failure. The mind is being forced to repeatedly rebuild a partially collapsed framework, and what feels like exhaustion is often just cumulative reconstruction effort. The work has not become harder; the conditions that allow sustained thought have been undermined.

The deeper implication is that the primary constraint of modern knowledge work is not information access or processing speed, but context preservation. Tools, texts, and systems that optimize for volume, immediacy, or breadth while ignoring continuity impose hidden costs on thinking. They may increase local efficiency, but they do so by quietly taxing the very structures that make deep, sustained understanding possible. Until this tradeoff is taken seriously, most attempts to improve knowledge work will continue to optimize the surface of the process while eroding its foundation.
                    </p>

                    <p style="font-size: 32px; line-height: 1.8; color: #4b5563; text-align: justify; margin-bottom: 40px; font-weight: 400;">
                        When technology works this way, expectations change. People stop asking whether something is possible and start asking what else they can do. Work becomes more ambitious. Learning becomes more expansive. Creativity stretches beyond familiar boundaries. That's the real promise here—not faster answers, but new possibilities. When intelligence becomes intuitive, personal, and inspiring, people don't just move quicker. They move further.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div id="success-modal">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeModal()">×</button>
            <img src="images/welcome_logo.png" alt="Welcome" class="modal-logo">
            <p><strong>Tangent exists to support thinking, not replace it.</strong></p>
            <p class="modal-subtitle">Keep an eye on your inbox.<br>Early access begins soon.</p>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <!-- Demo Tangent panel (OUTSIDE .tutorial-content for true fixed positioning) -->
    <div id="interactive-tangent-panel" style="display: none; position: fixed; width: 370px; height: 410px; max-width: 90%; margin-top: 20px; background: linear-gradient(to bottom, #dce4ea 0%, #c4ced6 100%) !important; border-radius: 12px; border-top: 4px solid rgba(255, 255, 255, 0.9) !important; border-left: 4px solid rgba(255, 255, 255, 0.9) !important; border-right: 4px solid rgba(0, 0, 0, 0.35) !important; border-bottom: 4px solid rgba(0, 0, 0, 0.35) !important; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12), 0 4px 8px rgba(0, 0, 0, 0.08), inset 0 1px 1px rgba(255, 255, 255, 0.9) !important; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Inter, sans-serif; color: #0f141a; z-index: 9998; overflow: hidden;">
        <!-- Pin button (top left, shifted inward and down) -->
        <div id="interactive-pin-btn" style="position: absolute; left: 16px; top: 14px; width: 20px; height: 20px; cursor: pointer; z-index: 10; transition: filter 0.2s ease;">
            <img src="images/pin_icon.png" alt="Pin" style="width: 20px; height: 20px;">
        </div>

        <!-- Control buttons (top right) -->
        <div style="position: absolute; right: 8px; top: 8px; display: flex; gap: 6px; z-index: 10;">
            <button id="interactive-minimize-btn" style="width: 20px; height: 20px; border: none; background: transparent; cursor: pointer; padding: 0;">
                <img src="images/minimize_icon.png" alt="Minimize" style="width: 20px; height: 20px;">
            </button>
            <button id="interactive-close-btn" style="width: 20px; height: 20px; border: none; background: transparent; cursor: pointer; padding: 0;">
                <img src="images/close_icon.png" alt="Close" style="width: 20px; height: 20px;">
            </button>
        </div>

        <!-- Flexbox container for proper layout -->
        <div style="display: flex; flex-direction: column; height: 100%; position: relative;">
            <!-- Header -->
            <div id="interactive-panel-header" style="padding: 12px; text-align: center; flex-shrink: 0;">
                <img src="images/tangent_logo_waitlist.png" alt="TANGENT" style="height: 28px; width: auto;">
            </div>

            <!-- Chat messages (flex: 1 to fill available space) -->
            <div id="interactive-chat-body" style="padding: 20px; overflow-y: auto; flex: 1;">
                <!-- Messages added via JS -->
            </div>

            <!-- Input area (flush to bottom) -->
            <div style="padding: 12px 16px; flex-shrink: 0; position: relative;">
                <input type="text" id="interactive-chat-input" placeholder="Go on a Tangent..." readonly style="width: 100%; padding: 14px 60px 14px 16px; border-radius: 24px; border: 2px solid #4a90e2; background: rgba(255, 255, 255, 0.9); font-size: 14px; font-style: italic; outline: none; box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);">

                <button id="interactive-chat-send" style="position: absolute; right: 22px; top: 50%; transform: translateY(-50%); width: 34px; height: 34px; border-radius: 50%; border: 2px solid #787878; background: transparent; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);">
                    <img id="interactive-chat-send-icon" src="images/tangent_enter_button.png" alt="Send" style="width: 18px; height: 18px;">
                </button>
                <style>
                    /* Make stop icon grey and smaller */
                    #interactive-chat-send-icon[src*="stop.svg"] {
                        width: 12px !important;
                        height: 12px !important;
                        filter: invert(48%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(95%) contrast(85%);
                    }
                </style>
            </div>
        </div>

        <!-- Resize handle (bottom-right corner) -->
        <div id="interactive-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; z-index: 11;"></div>
    </div>

    <!-- Demo cursor (OUTSIDE transformed panel for true fixed positioning) -->
    <div id="interactive-demo-cursor" class="demo-cursor" style="display: none; position: fixed; pointer-events: none; z-index: 10000;">
        <img src="images/cursor.png" alt="Cursor">
    </div>

    <!-- Demo chip bar (OUTSIDE transformed panel for true fixed positioning) -->
    <div id="interactive-chip-bar" class="chip-bar" style="display: none; position: fixed; z-index: 9999; transform: scale(1.15); transform-origin: center; border-radius: 14px;">
        <div style="display: flex; gap: 6px; align-items: center;">
            <button class="chip chip-icon" style="padding: 6px; min-width: 32px;">
                <img src="images/tangent_t_logo.png" alt="T" style="width: 18px; height: 18px;">
            </button>
            <button class="chip" id="interactive-context-chip" style="font-size: 1em; padding: 6px 10px;">What is...</button>
            <button class="chip" style="font-size: 1em; padding: 6px 10px;">Context</button>
            <button class="chip" style="font-size: 1em; padding: 6px 10px;">Summarize</button>
            <button class="chip chip-icon chevron-chip" style="padding: 5px; min-width: 27px; min-height: 27px;">
                <img src="images/chevron_down_arrow.png" alt="More" style="width: 15px; height: 15px;">
            </button>
        </div>
    </div>

    <script>
        // Main intro elements
        const mainText = document.getElementById('main-text');
        const highlightText = document.getElementById('highlight-text');
        const cursor = document.getElementById('demo-cursor');
        const cursorImg = document.getElementById('cursor-img');
        const chipBar = document.getElementById('chip-bar');
        const chipsContainer = document.getElementById('chips-container');
        const emailContainer = document.getElementById('email-container');
        const tChip = document.getElementById('t-chip');
        const tChipEmail = document.getElementById('t-chip-email');
        const emailInput = document.getElementById('email-input');
        const sendBtn = document.getElementById('send-btn');
        const tangentPanel = document.getElementById('tangent-panel');
        const panelHeader = document.querySelector('.tangent-panel__header');
        const minimizeBtn = document.querySelector('.tangent-panel__btns button[title="Minimize"]');
        const closeBtn = document.querySelector('.tangent-panel__btns button[title="Close"]');
        const tutorialContent = document.querySelector('.tutorial-content');
        const successModal = document.getElementById('success-modal');
        const toast = document.getElementById('toast');

        let panelExpanded = false;

        // Saved chip bar state (before panel expansion)
        let savedChipBarState = {
            position: '',
            left: '',
            top: '',
            transform: '',
            width: '',
            display: '',
            classes: []
        };

        // Utility functions
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 3000);
        }

        function closeModal() {
            successModal.classList.remove('visible');
        }

        function moveCursor(x, y) {
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';
        }

        function showCursor() {
            cursor.style.display = 'block';
            cursor.style.opacity = '0';
            setTimeout(() => {
                cursor.style.opacity = '1';
            }, 50);
        }

        function hideCursor() {
            cursor.style.opacity = '0';
            setTimeout(() => {
                cursor.style.display = 'none';
            }, 300);
        }

        function setCursorType(type) {
            if (type === 'normal') {
                cursorImg.src = 'images/cursor.png';
            } else {
                cursorImg.src = 'images/i_beam.png';
            }
        }

        function positionChipBar() {
            const textRect = highlightText.getBoundingClientRect();
            chipBar.style.left = (textRect.left + textRect.width / 2 - chipBar.offsetWidth / 2) + 'px';
            chipBar.style.top = (textRect.bottom + 12) + 'px';
        }

        // Main intro animation
        async function playIntro() {
            const startX = window.innerWidth - 200;
            const startY = window.innerHeight / 2;
            moveCursor(startX, startY);
            showCursor();
            setCursorType('normal');

            await wait(500);

            const textRect = highlightText.getBoundingClientRect();
            const startTextX = textRect.left - 30;
            const startTextY = textRect.top + (textRect.height / 2) - 5;
            moveCursor(startTextX, startTextY);

            tangentPanel.classList.add('visible');

            await wait(600);

            setCursorType('i_beam');

            await wait(200);

            highlightText.classList.add('highlighted');
            await wait(50);

            chipBar.style.display = 'flex';
            positionChipBar();
            await wait(50);
            chipBar.classList.add('visible');

            const text = highlightText.textContent;
            const textLength = text.length;
            const stepDuration = 500 / textLength;

            const endTextX = textRect.right + 2;
            const endTextY = textRect.top + (textRect.height / 2) - 5;
            moveCursor(endTextX, endTextY);

            const highlightStyle = document.createElement('style');
            highlightStyle.id = 'highlight-animation-style';
            document.head.appendChild(highlightStyle);

            for (let i = 0; i <= textLength; i++) {
                const percent = (i / textLength) * 100;
                highlightStyle.textContent = `
                    #highlight-text.highlighted::before {
                        width: ${percent}% !important;
                    }
                `;
                await wait(stepDuration);
            }

            await wait(100);

            await wait(700);

            setCursorType('normal');

            const tChipRect = tChip.getBoundingClientRect();
            const tChipCenterX = tChipRect.left + tChipRect.width / 2;
            const tChipCenterY = tChipRect.top + tChipRect.height / 2;
            moveCursor(tChipCenterX, tChipCenterY);

            await wait(800);

            tChip.style.transform = 'scale(0.95)';
            await wait(100);
            tChip.style.transform = '';

            await wait(300);

            chipsContainer.style.display = 'none';
            emailContainer.style.display = 'flex';
            chipBar.classList.remove('initial-state');
            chipBar.classList.add('email-state');

            positionChipBar();

            await wait(100);

            hideCursor();

            await wait(300);
            emailInput.focus();
        }

        // Email submission
        async function handleSubmit(e) {
            e.preventDefault();

            const email = emailInput.value.trim();

            if (!email) {
                showToast('Please enter an email address');
                return;
            }

            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                showToast('Please enter a valid email address');
                return;
            }

            sendBtn.disabled = true;
            emailInput.disabled = true;

            try {
                const referrer = document.referrer || 'Direct';

                const response = await fetch('https://tangent-backend-aaron-gantts-projects.vercel.app/api/waitlist', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email,
                        referrer
                    })
                });

                if (response.ok) {
                    successModal.classList.add('visible');
                    emailInput.value = '';
                } else {
                    showToast('Failed to join waitlist. Please try again.');
                }
            } catch (error) {
                console.error('Error:', error);
                showToast('Failed to join waitlist. Please try again.');
            } finally {
                sendBtn.disabled = false;
                emailInput.disabled = false;
            }
        }

        // Panel collapse
        function collapsePanel() {
            panelExpanded = false;
            tangentPanel.classList.remove('expanded');
            tutorialContent.style.display = 'none';

            // Hide interactive demo elements
            const interactiveTangentPanel = document.getElementById('interactive-tangent-panel');
            const interactiveChipBar = document.getElementById('interactive-chip-bar');
            if (interactiveTangentPanel) {
                interactiveTangentPanel.style.display = 'none';
            }
            if (interactiveChipBar) {
                interactiveChipBar.style.display = 'none';
            }

            // Reset main text position
            mainText.classList.remove('shifted-up');

            // Restore chip bar to pre-expansion state
            chipBar.className = '';
            savedChipBarState.classes.forEach(cls => chipBar.classList.add(cls));
            chipBar.style.position = savedChipBarState.position;
            chipBar.style.left = savedChipBarState.left;
            chipBar.style.top = savedChipBarState.top;
            chipBar.style.transform = savedChipBarState.transform;
            chipBar.style.width = savedChipBarState.width;
            chipBar.style.display = savedChipBarState.display;

            // Reset first loop flag when collapsing
            firstLoopComplete = false;

            // Stop any ongoing demo
            isDemoPaused = true;
            isInteractive = false;
            demoStarted = false;
            if (demoLoopTimeout) {
                clearTimeout(demoLoopTimeout);
            }
        }

        // Panel expand
        tangentPanel.addEventListener('click', (e) => {
            if (e.target.closest('.tangent-panel__btns') ||
                (panelExpanded && e.target.closest('.tangent-panel__header'))) {
                return;
            }

            if (panelExpanded || e.target.closest('.tutorial-content')) {
                return;
            }

            // Save chip bar state before expansion
            savedChipBarState.position = chipBar.style.position;
            savedChipBarState.left = chipBar.style.left;
            savedChipBarState.top = chipBar.style.top;
            savedChipBarState.transform = chipBar.style.transform;
            savedChipBarState.width = chipBar.style.width;
            savedChipBarState.display = chipBar.style.display;
            savedChipBarState.classes = Array.from(chipBar.classList);

            panelExpanded = true;
            tangentPanel.classList.add('expanded');
            tutorialContent.style.display = 'block';

            if (chipBar.classList.contains('visible')) {
                const currentTop = parseInt(chipBar.style.top) || 0;
                const textShiftAmount = 80;
                chipBar.style.top = (currentTop - textShiftAmount) + 'px';
            }

            mainText.classList.add('shifted-up');
            chipBar.classList.add('scaled-down');

            // Start the interactive demo
            isDemoPaused = false;
            isInteractive = false;
            console.log('Panel expanded, starting demo in 800ms. panelExpanded =', panelExpanded);
            setTimeout(() => {
                console.log('Timeout fired, calling playInteractiveDemo(). panelExpanded =', panelExpanded);
                playInteractiveDemo();
            }, 800);
        });

        panelHeader.addEventListener('click', (e) => {
            if (panelExpanded) {
                e.stopPropagation();
                collapsePanel();
            }
        });

        minimizeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (panelExpanded) {
                collapsePanel();
            }
        });

        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (panelExpanded) {
                collapsePanel();
            }
        });

        function toggleChipBarState() {
            const isEmailState = chipBar.classList.contains('email-state');

            if (isEmailState) {
                emailContainer.style.display = 'none';
                chipsContainer.style.display = 'flex';
                chipBar.classList.remove('email-state');
                chipBar.classList.add('initial-state');
            } else {
                chipsContainer.style.display = 'none';
                emailContainer.style.display = 'flex';
                chipBar.classList.remove('initial-state');
                chipBar.classList.add('email-state');
                emailInput.focus();
            }

            positionChipBar();
        }

        tChip.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleChipBarState();
        });

        tChipEmail.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleChipBarState();
        });

        successModal.addEventListener('click', (e) => {
            if (e.target === successModal) {
                successModal.classList.remove('visible');
            }
        });

        sendBtn.addEventListener('click', handleSubmit);

        emailInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSubmit(e);
            }
        });

        window.addEventListener('load', () => {
            setTimeout(() => {
                playIntro();
            }, 500);
        });

        window.addEventListener('resize', () => {
            if (chipBar.classList.contains('visible')) {
                positionChipBar();
            }
        });

        // ==================== INTERACTIVE DEMO ====================

        let demoLoopTimeout = null;
        let isDemoPaused = false;
        let isInteractive = false;
        let userHasMovedPanel = false;  // Track if user manually repositioned panel
        let demoStarted = false;
        let firstLoopComplete = false;

        // Get elements
        const demoHighlightText = document.getElementById('demo-highlight-text');
        const interactiveCursor = document.getElementById('interactive-demo-cursor');
        const interactiveChipBar = document.getElementById('interactive-chip-bar');
        const interactiveContextChip = document.getElementById('interactive-context-chip');
        const interactiveTangentPanel = document.getElementById('interactive-tangent-panel');
        const interactiveChatBody = document.getElementById('interactive-chat-body');
        const interactiveChatInput = document.getElementById('interactive-chat-input');
        const interactiveChatSend = document.getElementById('interactive-chat-send');

        // Step indicators
        const stepIndicator1 = document.getElementById('step-indicator-1');
        const stepIndicator2 = document.getElementById('step-indicator-2');
        const stepIndicator3 = document.getElementById('step-indicator-3');

        // Reset demo state
        function resetInteractiveDemo() {
            demoHighlightText.style.background = 'none';
            demoHighlightText.style.padding = '';
            demoHighlightText.classList.remove('highlighting');
            interactiveCursor.style.display = 'none';
            interactiveChipBar.style.display = 'none';
            interactiveTangentPanel.style.display = 'none';
            interactiveChatBody.innerHTML = '';
            interactiveChatInput.value = '';
            stepIndicator1.src = 'images/step_01.png';
            stepIndicator2.src = 'images/step_02.png';
            stepIndicator3.src = 'images/step_03.png';

            // Remove active glow from all step indicators
            stepIndicator1.classList.remove('active');
            stepIndicator2.classList.remove('active');
            stepIndicator3.classList.remove('active');

            // Remove any dynamic highlight style element
            const existingStyle = document.getElementById('demo-highlight-animation-style');
            if (existingStyle) {
                existingStyle.remove();
            }
        }

        // Add chat message
        function addInteractiveMessage(type, text) {
            const msg = document.createElement('div');
            msg.style.marginBottom = '20px';
            msg.style.textAlign = type === 'user' ? 'right' : 'left';

            const bubble = document.createElement('div');
            bubble.style.display = 'inline-block';
            bubble.style.padding = '12px 18px';
            bubble.style.borderRadius = '12px';
            bubble.style.maxWidth = '80%';
            bubble.style.background = type === 'user' ? 'rgba(255, 255, 255, 0.9)' : 'rgba(0, 0, 0, 0.05)';
            bubble.style.color = type === 'user' ? '#1a1a1a' : '#2a2a2a';
            bubble.textContent = text;

            msg.appendChild(bubble);
            interactiveChatBody.appendChild(msg);
            interactiveChatBody.scrollTop = interactiveChatBody.scrollHeight;
        }

        // Markdown to HTML converter
        function parseMarkdown(text) {
            let html = text;

            // Headers (## Header)
            html = html.replace(/^## (.+)$/gm, '<h3 style="font-size: 16px; font-weight: 700; margin: 16px 0 8px 0; color: #1a1a1a;">$1</h3>');

            // Bold (**text**)
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>');

            // Italics (*text*)
            html = html.replace(/\*(.+?)\*/g, '<em style="font-style: italic;">$1</em>');

            // Numbered lists (1. item)
            html = html.replace(/^(\d+)\.\s+(.+)$/gm, '<div style="margin-left: 20px; margin-bottom: 8px;"><span style="font-weight: 600;">$1.</span> $2</div>');

            // Bullet points (- item or * item)
            html = html.replace(/^[-*]\s+(.+)$/gm, '<div style="margin-left: 20px; margin-bottom: 8px;">• $1</div>');

            // Line breaks
            html = html.replace(/\n\n/g, '<br><br>');
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        // Helper function to fade transition step indicator images
        async function fadeStepIndicator(imgElement, newSrc) {
            // Fade out
            imgElement.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 400)); // Match CSS transition duration

            // Swap image
            imgElement.src = newSrc;

            // Fade in
            imgElement.style.opacity = '1';
        }

        // Global flag to stop typewriter effect
        let stopTyping = false;

        // Typewriter effect with HTML support
        async function typewriterEffect(element, text, speed = 0.5) {  // Very fast typing - 0.5ms per character
            // Show stop button
            const sendImg = document.getElementById('interactive-chat-send-icon');
            sendImg.src = 'images/stop.svg';
            stopTyping = false;

            const html = parseMarkdown(text);
            element.innerHTML = '';

            // Create temporary div to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;

            // Get all text nodes and HTML elements in order
            const walker = document.createTreeWalker(temp, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT);
            const nodes = [];
            let node;
            while (node = walker.nextNode()) {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                    nodes.push({ type: 'text', content: node.textContent, parent: node.parentNode });
                } else if (node.nodeType === Node.ELEMENT_NODE && ['H3', 'STRONG', 'EM', 'DIV', 'BR'].includes(node.tagName)) {
                    nodes.push({ type: 'element', node: node.cloneNode(false) });
                }
            }

            // Type out character by character
            let currentHTML = '';
            for (let char of text) {
                if (stopTyping) {
                    // Complete the text immediately if stopped
                    element.innerHTML = parseMarkdown(text);
                    break;
                }
                currentHTML += char;
                const formattedHTML = parseMarkdown(currentHTML);
                element.innerHTML = formattedHTML;
                interactiveChatBody.scrollTop = interactiveChatBody.scrollHeight;
                await wait(speed);
            }

            // Restore send button
            sendImg.src = 'images/tangent_enter_button.png';
        }

        // Main demo sequence
        async function playInteractiveDemo() {
            console.log('playInteractiveDemo called. isDemoPaused =', isDemoPaused, ', isInteractive =', isInteractive, ', panelExpanded =', panelExpanded);
            if (isDemoPaused || isInteractive || !panelExpanded) {
                console.log('Early return from playInteractiveDemo');
                return;
            }

            console.log('Starting demo animation...');
            demoStarted = true;  // Mark demo as started so mousemove can pause it
            resetInteractiveDemo();
            await wait(500);

            // STEP 1: Highlight text and show chip bar
            await fadeStepIndicator(stepIndicator1, 'images/step_01_blue.png');
            stepIndicator1.classList.add('active');

            // Get FINAL text position (where it will be AFTER scroll completes)
            const scrollArea = document.getElementById('demo-scroll-area');
            const highlightTextElement = document.getElementById('demo-highlight-text');

            // Position "Subtle cognitive cost" to show one more line above (25% down from top)
            // Get the parent paragraph's offsetTop since inline span doesn't have reliable offsetTop
            const highlightParagraph = highlightTextElement.closest('p');
            const scrollAreaHeight = scrollArea.clientHeight;
            const targetScrollPos = highlightParagraph.offsetTop - (scrollAreaHeight * 0.25);
            const currentScrollPos = scrollArea.scrollTop;
            const scrollDelta = targetScrollPos - currentScrollPos;

            // Get current position
            const currentTextRect = demoHighlightText.getBoundingClientRect();

            // Calculate FINAL position (current position - scroll delta)
            const textLeft = currentTextRect.left;
            const textTop = currentTextRect.top - scrollDelta;
            const textHeight = currentTextRect.height;
            const textWidth = currentTextRect.width;

            const textStartX = textLeft - 20;
            const textStartY = textTop + (textHeight / 2);
            const textEndX = textLeft + textWidth + 5;
            const textEndY = textTop + (textHeight / 2);

            // Start cursor from bottom right corner
            const startX = window.innerWidth + 50;
            const startY = window.innerHeight - 100;
            interactiveCursor.querySelector('img').src = 'images/cursor.png';
            interactiveCursor.style.left = startX + 'px';
            interactiveCursor.style.top = startY + 'px';
            interactiveCursor.style.display = 'block';
            interactiveCursor.style.transition = 'none';
            await wait(50);

            // START BOTH ANIMATIONS SIMULTANEOUSLY
            // 1. Start scroll animation
            if (scrollArea && highlightParagraph) {
                scrollArea.scrollTo({
                    top: Math.max(0, targetScrollPos),
                    behavior: 'smooth'
                });
            }

            // 2. Start cursor movement (to FINAL position, overlapping with scroll)
            interactiveCursor.style.transition = 'left 1s ease-out, top 1s ease-out';
            interactiveCursor.style.left = textStartX + 'px';
            interactiveCursor.style.top = textStartY + 'px';

            // Wait for BOTH to complete
            await wait(1000);

            // Change to I-beam cursor when hovering over text
            interactiveCursor.querySelector('img').src = 'images/i_beam.png';
            await wait(200);

            // Add highlighting class for animation
            demoHighlightText.classList.add('highlighting');
            demoHighlightText.style.padding = '0 4px';

            // Move cursor to end of text
            interactiveCursor.style.left = textEndX + 'px';
            interactiveCursor.style.top = textEndY + 'px';

            // Letter-by-letter highlight animation (same as main intro)
            const text = demoHighlightText.textContent;
            const textLength = text.length;
            const stepDuration = 800 / textLength;  // 800ms total for highlight animation

            const demoHighlightStyle = document.createElement('style');
            demoHighlightStyle.id = 'demo-highlight-animation-style';
            document.head.appendChild(demoHighlightStyle);

            for (let i = 0; i <= textLength; i++) {
                const percent = (i / textLength) * 100;
                demoHighlightStyle.textContent = `
                    #demo-highlight-text.highlighting::before {
                        width: ${percent}% !important;
                    }
                `;
                await wait(stepDuration);
            }

            await wait(200);

            // Change back to regular cursor after highlighting
            interactiveCursor.querySelector('img').src = 'images/cursor.png';
            await wait(100);

            // Show chip bar below highlighted text
            // Use the same manual position calculation as we did for the cursor
            // (reuse textLeft, textTop, textWidth, textHeight from above)

            // First show chip bar to get its actual width
            interactiveChipBar.style.display = 'flex';
            interactiveChipBar.style.opacity = '0'; // Invisible while we position it
            await wait(100);

            // Get actual chip bar width
            const chipBarRect = interactiveChipBar.getBoundingClientRect();
            const chipBarWidth = chipBarRect.width;

            // Center chip bar under the highlighted text using manual coordinates
            const chipBarLeft = textLeft + (textWidth / 2) - (chipBarWidth / 2);
            const chipBarTop = textTop + textHeight + 10;

            console.log('Chip bar positioning:', {
                textPosition: { left: textLeft, top: textTop, width: textWidth, height: textHeight },
                chipBarWidth,
                chipBarLeft,
                chipBarTop,
                textCenter: textLeft + (textWidth / 2),
                viewportWidth: window.innerWidth,
                viewportHeight: window.innerHeight
            });

            interactiveChipBar.style.left = chipBarLeft + 'px';
            interactiveChipBar.style.top = chipBarTop + 'px';
            interactiveChipBar.style.opacity = '1'; // Now make it visible
            await wait(500);  // Reduced from 1500ms to 500ms - move to chip sooner

            if (isDemoPaused || isInteractive) return;

            // STEP 2: Click Context chip
            await fadeStepIndicator(stepIndicator1, 'images/step_01.png');
            stepIndicator1.classList.remove('active');
            await fadeStepIndicator(stepIndicator2, 'images/step_02_blue.png');
            stepIndicator2.classList.add('active');

            // Cursor should already be visible at end of text
            // Animate cursor moving from current position to Context chip
            const chipRect = interactiveContextChip.getBoundingClientRect();
            const targetX = chipRect.left + chipRect.width / 2;
            const targetY = chipRect.top + chipRect.height / 2;

            // Cursor continues from its current position (end of text)
            interactiveCursor.style.transition = 'left 1s ease-out, top 1s ease-out';  // SLOWED DOWN from 0.5s
            interactiveCursor.style.left = targetX + 'px';
            interactiveCursor.style.top = targetY + 'px';
            await wait(1100);  // INCREASED to match slower animation (1000ms + 100ms buffer)

            // Click effect
            interactiveContextChip.style.transform = 'translateY(2px)';
            await wait(100);
            interactiveContextChip.style.transform = '';

            if (isDemoPaused || isInteractive) return;

            // STEP 3: Show Tangent panel IMMEDIATELY after click
            // Position panel at ABSOLUTE TOP of tutorial content (above step indicators)
            // BUT ONLY if user hasn't manually moved it AND demo isn't paused AND scroll listener not disabled
            if (!userHasMovedPanel && !isDemoPaused && !isInteractive && !scrollListenerDisabled) {
                const chipBarRectForPanel = interactiveChipBar.getBoundingClientRect();
                const tutorialContent = document.querySelector('.tutorial-content');
                const tutorialContentRect = tutorialContent.getBoundingClientRect();

                // DOUBLE CHECK right before modifying styles (in case flags changed during getBoundingClientRect calls)
                if (!userHasMovedPanel && !isDemoPaused && !isInteractive && !scrollListenerDisabled) {
                    // Position panel to the right of chip bar and near top of tutorial content
                    // Now that panel is outside .tutorial-content, position: fixed works correctly!
                    const calculatedLeft = (chipBarRectForPanel.left + 530);  // Adjusted from 150 (was compensating for old offset)
                    const calculatedTop = (tutorialContentRect.top + 120);  // Adjusted from -80 (was compensating for old offset)

                    interactiveTangentPanel.style.left = calculatedLeft + 'px';
                    interactiveTangentPanel.style.top = calculatedTop + 'px';
                    interactiveTangentPanel.style.transform = 'none';

                    // IMMEDIATELY check what getBoundingClientRect returns
                    const verifyRect = interactiveTangentPanel.getBoundingClientRect();

                    console.log('Tangent panel positioned at top of tutorial content:', {
                        chipBarRect: chipBarRectForPanel,
                        tutorialContentRect: tutorialContentRect,
                        calculatedLeft: calculatedLeft,
                        calculatedTop: calculatedTop,
                        inlineStyleLeft: interactiveTangentPanel.style.left,
                        inlineStyleTop: interactiveTangentPanel.style.top,
                        ACTUAL_rectLeft: verifyRect.left,
                        ACTUAL_rectTop: verifyRect.top,
                        MISMATCH: verifyRect.left !== calculatedLeft ? `YES! ${verifyRect.left} !== ${calculatedLeft}` : 'NO'
                    });
                } else {
                    console.log('🛑 Positioning BLOCKED - flags changed during execution!');
                }
            }
            interactiveTangentPanel.style.display = 'block';
            // Opacity controlled by inline CSS background rgba values (0.7 alpha = 70% transparent for glass blur)
            await wait(300);

            // Add AI response with typewriter - normal format (no bubble, no user message)
            const aiMsg = document.createElement('div');
            aiMsg.style.marginBottom = '20px';
            aiMsg.style.textAlign = 'left';
            aiMsg.style.padding = '0';
            aiMsg.style.color = '#2a2a2a';
            aiMsg.style.fontSize = '14px';
            aiMsg.style.lineHeight = '1.6';

            interactiveChatBody.appendChild(aiMsg);

            const aiResponse = `In this passage, the author explains that **continuity in reading is fragile**, and that even brief interruptions can weaken a reader's ability to stay oriented within a line of thought. The issue is not *distraction* in the usual sense, but the way attention supports an internal structure of reasoning that degrades when it is broken.

The "cost" being described is therefore not the time spent searching for information elsewhere, but the **mental effort required to reconstruct the original reasoning** upon return. The reader must re-establish context, recall what mattered, and rebuild coherence before progress can continue.`;

            // Start typewriter effect and wait for it to complete
            await typewriterEffect(aiMsg, aiResponse, 0.5);

            // After typing is complete, switch to step 3 icon
            await fadeStepIndicator(stepIndicator2, 'images/step_02.png');
            stepIndicator2.classList.remove('active');
            await fadeStepIndicator(stepIndicator3, 'images/step_03_blue.png');
            stepIndicator3.classList.add('active');

            // Hide cursor after panel content is complete
            interactiveCursor.style.display = 'none';
            interactiveCursor.style.transition = '';

            await wait(8000);  // Linger on final state

            if (isDemoPaused || isInteractive) return;

            // Mark first loop as complete
            firstLoopComplete = true;

            // Wait at least 30 seconds before looping (30000ms total - 8000ms already waited = 22000ms more)
            demoLoopTimeout = setTimeout(playInteractiveDemo, 22000);
        }

        // Scroll handler - keep chip bar locked to "Tangent" text position
        const demoScrollArea = document.getElementById('demo-scroll-area');
        if (demoScrollArea) {
            demoScrollArea.addEventListener('scroll', () => {
                // Only reposition if chip bar is visible and demo is running
                if (interactiveChipBar.style.display === 'flex' && panelExpanded) {
                    // Recalculate text position
                    const updatedTextRect = demoHighlightText.getBoundingClientRect();
                    const updatedTextLeft = updatedTextRect.left;
                    const updatedTextTop = updatedTextRect.top;
                    const updatedTextWidth = updatedTextRect.width;
                    const updatedTextHeight = updatedTextRect.height;

                    // Recalculate chip bar position
                    const chipBarRect = interactiveChipBar.getBoundingClientRect();
                    const chipBarWidth = chipBarRect.width;
                    const newChipBarLeft = updatedTextLeft + (updatedTextWidth / 2) - (chipBarWidth / 2);
                    const newChipBarTop = updatedTextTop + updatedTextHeight + 10;

                    // Update chip bar position
                    interactiveChipBar.style.left = newChipBarLeft + 'px';
                    interactiveChipBar.style.top = newChipBarTop + 'px';

                    // Also update Tangent panel position if it's visible (at top of tutorial content)
                    // BUT ONLY if user has NOT manually moved it and is NOT currently dragging it!
                    // Use requestAnimationFrame to defer until after mousedown completes
                    // ALSO check scrollListenerDisabled flag (nuclear option)
                    requestAnimationFrame(() => {
                        if (scrollListenerDisabled) {
                            console.log('🚫 Scroll listener disabled - not repositioning panel');
                            return;
                        }
                        if (interactiveTangentPanel.style.display === 'block' && !isDraggingPanel && !userHasMovedPanel) {
                            const updatedChipBarRect = interactiveChipBar.getBoundingClientRect();
                            const updatedTutorialContent = document.querySelector('.tutorial-content');
                            const updatedTutorialContentRect = updatedTutorialContent.getBoundingClientRect();
                            interactiveTangentPanel.style.left = (updatedChipBarRect.left + 530) + 'px';  // Match new positioning
                            interactiveTangentPanel.style.top = (updatedTutorialContentRect.top + 120) + 'px';  // Match new positioning
                        }
                    });
                }
            });
        }

        // Mouse hover detection - pause after current loop (but only AFTER first loop completes)
        document.addEventListener('mousemove', () => {
            if (!isInteractive && !isDemoPaused && panelExpanded && demoStarted && firstLoopComplete) {
                console.log('Mouse move detected, pausing demo');
                isDemoPaused = true;

                // Let current animation finish, then enable interaction
                setTimeout(() => {
                    if (isDemoPaused) {
                        isInteractive = true;
                        clearTimeout(demoLoopTimeout);

                        // Keep all indicators blue in interactive mode
                        fadeStepIndicator(stepIndicator1, 'images/step_01_blue.png');
                        fadeStepIndicator(stepIndicator2, 'images/step_02_blue.png');
                        fadeStepIndicator(stepIndicator3, 'images/step_03_blue.png');
                    }
                }, 2000);
            }
        });

        // Close button - ONLY hide panel (keep chip bar visible so chips remain clickable)
        const interactiveCloseBtn = document.getElementById('interactive-close-btn');
        if (interactiveCloseBtn) {
            // Prevent mousedown from triggering drag FIRST (capture phase)
            interactiveCloseBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            // Then handle the click
            interactiveCloseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                console.log('Close button clicked');
                interactiveTangentPanel.style.display = 'none';
                isDemoPaused = true;
                isInteractive = true;
                clearTimeout(demoLoopTimeout);
            }, true);
        }

        // Minimize button - just hide panel (keep chip bar visible)
        const interactiveMinimizeBtn = document.getElementById('interactive-minimize-btn');
        if (interactiveMinimizeBtn) {
            // Prevent mousedown from triggering drag FIRST (capture phase)
            interactiveMinimizeBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            // Then handle the click
            interactiveMinimizeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                console.log('Minimize button clicked');

                // Toggle minimized state
                const isMinimized = interactiveTangentPanel.classList.contains('minimized');

                if (isMinimized) {
                    // Expand back to full size
                    interactiveTangentPanel.classList.remove('minimized');
                    interactiveTangentPanel.style.height = '410px';
                    interactiveTangentPanel.style.width = '370px';
                } else {
                    // Minimize to just header bar
                    interactiveTangentPanel.classList.add('minimized');
                    interactiveTangentPanel.style.height = '52px';  // Just tall enough for header
                    interactiveTangentPanel.style.width = '252px';  // Match reference width
                }
            }, true);
        }

        // Make ALL chips in the chip bar clickable to open the panel
        const allDemoChips = interactiveChipBar.querySelectorAll('.chip:not(.chevron-chip)');
        allDemoChips.forEach(chip => {
            chip.addEventListener('click', async (e) => {
                e.stopPropagation();

                // Pause demo if running
                isDemoPaused = true;
                isInteractive = true;
                clearTimeout(demoLoopTimeout);

                // Hide the simulated cursor
                interactiveCursor.style.display = 'none';

                // Keep all step indicators blue in interactive mode
                fadeStepIndicator(stepIndicator1, 'images/step_01_blue.png');
                fadeStepIndicator(stepIndicator2, 'images/step_02_blue.png');
                fadeStepIndicator(stepIndicator3, 'images/step_03_blue.png');

                // Visual click effect
                chip.style.transform = 'translateY(2px)';
                await new Promise(resolve => setTimeout(resolve, 100));
                chip.style.transform = '';

                // Show panel if not already visible
                if (interactiveTangentPanel.style.display !== 'block') {
                    interactiveTangentPanel.style.display = 'block';
                }

                // Clear and show AI response based on which chip was clicked
                interactiveChatBody.innerHTML = '';
                const aiMsg = document.createElement('div');
                aiMsg.style.marginBottom = '20px';
                aiMsg.style.textAlign = 'left';
                aiMsg.style.padding = '0';
                aiMsg.style.color = '#2a2a2a';
                aiMsg.style.fontSize = '14px';
                aiMsg.style.lineHeight = '1.6';
                interactiveChatBody.appendChild(aiMsg);

                // Determine response based on chip text
                const chipText = chip.textContent.trim();
                let aiResponse = '';

                if (chipText === 'What is...') {
                    aiResponse = `Here, **subtle cognitive cost** refers to the additional mental effort imposed when a continuous line of thought is interrupted. It is not the difficulty of the material itself, but the effort required to recover orientation after disengaging. The cost is subtle because it does not present as confusion or error; it appears as *lost momentum*, a faint resistance to resuming thought.`;
                } else if (chipText === 'Context') {
                    aiResponse = `In this passage, the author explains that **continuity in reading is fragile**, and that even brief interruptions can weaken a reader's ability to stay oriented within a line of thought. The issue is not *distraction* in the usual sense, but the way attention supports an internal structure of reasoning that degrades when it is broken.

The "cost" being described is therefore not the time spent searching for information elsewhere, but the **mental effort required to reconstruct the original reasoning** upon return. The reader must re-establish context, recall what mattered, and rebuild coherence before progress can continue.`;
                } else if (chipText === 'Summarize') {
                    aiResponse = `Leaving a page to resolve small uncertainties fragments attention by breaking the continuity that sustained understanding depends on. Even when the interruption is brief and purposeful, it **suspends the reader's internal orientation**: the sense of what is being argued, why it matters, and how the current point fits into a larger structure.

Each interruption introduces a *subtle cognitive cost*—not in the time spent away, but in the effort required to reconstruct that orientation when returning. As these costs accumulate, maintaining a coherent line of thought becomes progressively harder, not because the material is more complex, but because **continuity has been repeatedly compromised**.`;
                }

                await typewriterEffect(aiMsg, aiResponse, 2);
            });
        });

        // Stop button functionality
        interactiveChatSend.addEventListener('click', (e) => {
            e.stopPropagation();
            const sendImg = document.getElementById('interactive-chat-send-icon');
            // Check if stop icon is showing (typing in progress)
            if (sendImg.src.includes('stop.svg')) {
                stopTyping = true;
            }
        });

        // Drag-to-move functionality for the panel
        let isDraggingPanel = false;  // Renamed to avoid conflict with other isDragging variables
        let panelDragOffsetX = 0;
        let panelDragOffsetY = 0;
        let savedPanelLeft = 0;  // Save position at mousedown
        let savedPanelTop = 0;
        let lockPositionLoop = null;  // RAF loop to continuously lock position
        let scrollListenerDisabled = false;  // NUCLEAR option to completely disable scroll repositioning
        let lastHeaderClickTime = 0;  // For double-click detection

        // Double-click header to minimize
        interactiveTangentPanel.addEventListener('dblclick', (e) => {
            if (e.target.closest('#interactive-panel-header')) {
                e.preventDefault();
                e.stopPropagation();

                // Trigger minimize toggle
                const isMinimized = interactiveTangentPanel.classList.contains('minimized');
                if (isMinimized) {
                    interactiveTangentPanel.classList.remove('minimized');
                    interactiveTangentPanel.style.height = '410px';
                    interactiveTangentPanel.style.width = '370px';
                } else {
                    interactiveTangentPanel.classList.add('minimized');
                    interactiveTangentPanel.style.height = '52px';
                    interactiveTangentPanel.style.width = '252px';
                }
            }
        });

        interactiveTangentPanel.addEventListener('mousedown', (e) => {
            // ONLY allow dragging from the header area - must be inside header
            if (!e.target.closest('#interactive-panel-header')) {
                return;
            }

            // Don't drag if clicking on buttons
            if (e.target.closest('#interactive-minimize-btn') ||
                e.target.closest('#interactive-close-btn') ||
                e.target.closest('#interactive-pin-btn')) {
                return;
            }

            // NUCLEAR: Disable scroll listener FIRST, before anything else
            scrollListenerDisabled = true;
            console.log('💣 SCROLL LISTENER DISABLED');

            console.log('🎯 MOUSEDOWN START');

            // CRITICAL: Capture current position IMMEDIATELY before anything else
            const panelRect = interactiveTangentPanel.getBoundingClientRect();
            savedPanelLeft = panelRect.left;
            savedPanelTop = panelRect.top;

            // Check inline styles AND computed styles
            const computedStyle = window.getComputedStyle(interactiveTangentPanel);
            console.log('📍 Captured position:', {
                rectLeft: savedPanelLeft,
                rectTop: savedPanelTop,
                inlineLeft: interactiveTangentPanel.style.left,
                inlineTop: interactiveTangentPanel.style.top,
                computedLeft: computedStyle.left,
                computedTop: computedStyle.top,
                computedTransform: computedStyle.transform,
                mouseX: e.clientX,
                mouseY: e.clientY,
                DIFF: `inline ${interactiveTangentPanel.style.left} → rect ${savedPanelLeft}px = +${(savedPanelLeft - parseFloat(interactiveTangentPanel.style.left)).toFixed(1)}px mystery offset!`
            });

            // 🔍 DEBUG: Check if any ancestor creates containing block for position:fixed
            let ancestorEl = interactiveTangentPanel;
            console.log('🔍 CHECKING ALL ANCESTORS FOR CONTAINING BLOCK:');
            while (ancestorEl = ancestorEl.parentElement) {
                const ancestorComputed = window.getComputedStyle(ancestorEl);
                const elementName = ancestorEl.id || ancestorEl.className || ancestorEl.tagName;
                if (ancestorComputed.transform !== 'none' ||
                    ancestorComputed.perspective !== 'none' ||
                    ancestorComputed.filter !== 'none' ||
                    ancestorComputed.backdropFilter !== 'none' ||
                    ancestorComputed.willChange !== 'auto') {
                    console.log('⚠️ CONTAINING BLOCK FOUND:', {
                        element: elementName,
                        transform: ancestorComputed.transform,
                        perspective: ancestorComputed.perspective,
                        filter: ancestorComputed.filter,
                        backdropFilter: ancestorComputed.backdropFilter,
                        willChange: ancestorComputed.willChange,
                        position: ancestorComputed.position
                    });
                } else if (elementName.includes('tutorial')) {
                    console.log(`✓ Ancestor: ${elementName} (position: ${ancestorComputed.position}, overflow: ${ancestorComputed.overflow})`);
                }
            }

            // Calculate offset from mouse to panel's current position
            panelDragOffsetX = e.clientX - savedPanelLeft;
            panelDragOffsetY = e.clientY - savedPanelTop;

            // Set flags to indicate ready to drag
            isDraggingPanel = true;
            userHasMovedPanel = true;

            // PAUSE THE DEMO immediately
            isDemoPaused = true;
            isInteractive = true;
            clearTimeout(demoLoopTimeout);

            // Hide the simulated cursor
            interactiveCursor.style.display = 'none';

            // Keep all step indicators blue in interactive mode
            fadeStepIndicator(stepIndicator1, 'images/step_01_blue.png');
            fadeStepIndicator(stepIndicator2, 'images/step_02_blue.png');
            fadeStepIndicator(stepIndicator3, 'images/step_03_blue.png');

            // Check position after a brief delay to see if something else changed it
            setTimeout(() => {
                const checkRect = interactiveTangentPanel.getBoundingClientRect();
                console.log('⏱️ Position after 10ms:', { left: checkRect.left, top: checkRect.top });
                if (Math.abs(checkRect.left - savedPanelLeft) > 1 || Math.abs(checkRect.top - savedPanelTop) > 1) {
                    console.error('❌ POSITION CHANGED! Something else moved it!');
                }
            }, 10);

            // Change cursor to grabbing on the whole panel while dragging
            interactiveTangentPanel.style.cursor = 'grabbing';
            e.preventDefault();
            e.stopPropagation();  // Prevent other click handlers
        }, true);  // Use capture phase to run BEFORE other handlers

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingPanel) return;

            // Calculate new position based on mouse and offset
            const newLeft = e.clientX - panelDragOffsetX;
            const newTop = e.clientY - panelDragOffsetY;

            // Update panel position with direct pixel values
            interactiveTangentPanel.style.left = newLeft + 'px';
            interactiveTangentPanel.style.top = newTop + 'px';
            interactiveTangentPanel.style.transform = 'none';  // Remove any transform
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingPanel) {
                isDraggingPanel = false;
                // Reset cursor to default (will show move cursor when hovering over header)
                interactiveTangentPanel.style.cursor = '';
            }
        });

        // Resize functionality
        const interactiveResizeHandle = document.getElementById('interactive-resize-handle');
        let isResizing = false;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let resizeStartWidth = 0;
        let resizeStartHeight = 0;

        if (interactiveResizeHandle) {
            interactiveResizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                isResizing = true;
                resizeStartX = e.clientX;
                resizeStartY = e.clientY;
                resizeStartWidth = interactiveTangentPanel.offsetWidth;
                resizeStartHeight = interactiveTangentPanel.offsetHeight;

                document.body.style.cursor = 'nwse-resize';
                document.body.style.userSelect = 'none';
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            const deltaX = e.clientX - resizeStartX;
            const deltaY = e.clientY - resizeStartY;

            const newWidth = Math.max(300, resizeStartWidth + deltaX);  // Min width 300px
            const newHeight = Math.max(250, resizeStartHeight + deltaY);  // Min height 250px

            interactiveTangentPanel.style.width = newWidth + 'px';
            interactiveTangentPanel.style.height = newHeight + 'px';
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // Pin button - toggle blue color when clicked
        const interactivePinBtn = document.getElementById('interactive-pin-btn');
        let isPinned = false;
        if (interactivePinBtn) {
            // Prevent mousedown from triggering drag FIRST (capture phase)
            interactivePinBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }, true);

            // Then handle the click
            interactivePinBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();

                isPinned = !isPinned;
                console.log('Pin button clicked, isPinned:', isPinned);

                // Toggle blue filter (Tangent blue #4a90e2)
                if (isPinned) {
                    interactivePinBtn.style.filter = 'brightness(0) saturate(100%) invert(47%) sepia(94%) saturate(1285%) hue-rotate(196deg) brightness(95%) contrast(91%)';
                } else {
                    interactivePinBtn.style.filter = 'none';
                }
            }, true);
        }

        // Old step demo functions (kept for compatibility but not used)
        async function playStep1Demo() {
            const step1Cursor = document.getElementById('step1-cursor');
            const step1Text = document.getElementById('step1-text');
            const step1Highlight = document.getElementById('step1-highlight');
            const step1Chipbar = document.getElementById('step1-chipbar');

            // Position cursor at start of "Discover"
            const highlightRect = step1Highlight.getBoundingClientRect();
            const startX = highlightRect.left - 30;
            const startY = highlightRect.top + (highlightRect.height / 2);

            step1Cursor.style.left = startX + 'px';
            step1Cursor.style.top = startY + 'px';
            step1Cursor.style.display = 'block';
            step1Cursor.style.opacity = '1';

            await wait(500);

            // Change to I-beam
            step1Cursor.querySelector('img').src = 'images/i_beam.png';

            await wait(200);

            // Start highlighting
            step1Highlight.classList.add('highlighted');

            // Move cursor to end
            const endX = highlightRect.right + 2;
            const endY = highlightRect.top + (highlightRect.height / 2);
            step1Cursor.style.left = endX + 'px';
            step1Cursor.style.top = endY + 'px';

            // Animate highlight
            const text = step1Highlight.textContent;
            const textLength = text.length;
            const stepDuration = 500 / textLength;

            const step1Style = document.createElement('style');
            step1Style.id = 'step1-highlight-style';
            document.head.appendChild(step1Style);

            for (let i = 0; i <= textLength; i++) {
                const percent = (i / textLength) * 100;
                step1Style.textContent = `
                    #step1-highlight.highlighted::before {
                        width: ${percent}% !important;
                    }
                `;
                await wait(stepDuration);
            }

            await wait(300);

            // Show chip bar below text
            const textRect = step1Text.getBoundingClientRect();
            step1Chipbar.style.left = (textRect.left + textRect.width / 2 - step1Chipbar.offsetWidth / 2) + 'px';
            step1Chipbar.style.top = (highlightRect.bottom + 12) + 'px';
            step1Chipbar.style.display = 'flex';
            await wait(50);
            step1Chipbar.classList.add('visible');

            // Hide cursor
            step1Cursor.style.opacity = '0';
            await wait(300);
            step1Cursor.style.display = 'none';

            // Wait then start step 2
            await wait(1500);
            playStep2Demo();
        }

        // STEP 2: Click Context chip, switch to text input, type message
        async function playStep2Demo() {
            const step2Cursor = document.getElementById('step2-cursor');
            const step2Highlight = document.getElementById('step2-highlight');
            const step2Chipbar = document.getElementById('step2-chipbar');
            const step2Chips = document.getElementById('step2-chips');
            const step2Email = document.getElementById('step2-email');
            const step2ContextChip = document.getElementById('step2-context-chip');
            const step2TChip = document.getElementById('step2-t-chip');
            const step2Input = document.getElementById('step2-input');
            const step2Send = document.getElementById('step2-send');

            // Set up highlight (already highlighted from step 1 state)
            const step2Style = document.createElement('style');
            step2Style.textContent = `
                #step2-highlight.highlighted::before {
                    width: 100% !important;
                }
            `;
            document.head.appendChild(step2Style);

            // Position chip bar
            const highlightRect = step2Highlight.getBoundingClientRect();
            step2Chipbar.style.left = (highlightRect.left + highlightRect.width / 2 - step2Chipbar.offsetWidth / 2) + 'px';
            step2Chipbar.style.top = (highlightRect.bottom + 12) + 'px';

            await wait(500);

            // Show cursor at Context chip
            const contextRect = step2ContextChip.getBoundingClientRect();
            const contextX = contextRect.left + contextRect.width / 2;
            const contextY = contextRect.top + contextRect.height / 2;

            step2Cursor.querySelector('img').src = 'images/cursor.png';
            step2Cursor.style.left = contextX + 'px';
            step2Cursor.style.top = contextY + 'px';
            step2Cursor.style.display = 'block';
            step2Cursor.style.opacity = '1';

            await wait(600);

            // Click Context chip
            step2ContextChip.style.transform = 'scale(0.95)';
            await wait(100);
            step2ContextChip.style.transform = '';

            await wait(400);

            // Move cursor to T chip
            const tChipRect = step2TChip.getBoundingClientRect();
            const tChipX = tChipRect.left + tChipRect.width / 2;
            const tChipY = tChipRect.top + tChipRect.height / 2;

            step2Cursor.style.left = tChipX + 'px';
            step2Cursor.style.top = tChipY + 'px';

            await wait(600);

            // Click T chip
            step2TChip.style.transform = 'scale(0.95)';
            await wait(100);
            step2TChip.style.transform = '';

            await wait(300);

            // Transform to email input
            step2Chips.style.display = 'none';
            step2Email.style.display = 'flex';
            step2Chipbar.classList.remove('initial-state');
            step2Chipbar.classList.add('email-state');

            // Reposition chip bar
            step2Chipbar.style.left = (highlightRect.left + highlightRect.width / 2 - step2Chipbar.offsetWidth / 2) + 'px';

            await wait(400);

            // Hide cursor briefly
            step2Cursor.style.opacity = '0';

            await wait(200);

            // Type "Tell me more."
            const message = "Tell me more.";
            step2Input.value = '';

            for (let i = 0; i <= message.length; i++) {
                step2Input.value = message.substring(0, i);
                await wait(80);
            }

            await wait(400);

            // Move cursor to send button
            const sendRect = step2Send.getBoundingClientRect();
            const sendX = sendRect.left + sendRect.width / 2;
            const sendY = sendRect.top + sendRect.height / 2;

            step2Cursor.style.left = sendX + 'px';
            step2Cursor.style.top = sendY + 'px';
            step2Cursor.style.opacity = '1';

            await wait(600);

            // Click send button
            step2Send.style.transform = 'translateY(-50%) scale(0.95)';
            await wait(100);
            step2Send.style.transform = '';

            // Hide cursor
            step2Cursor.style.opacity = '0';
            await wait(300);
            step2Cursor.style.display = 'none';

            // Wait then start step 3
            await wait(1000);
            playStep3Demo();
        }

        // STEP 3: Show chat panel with AI responses
        async function playStep3Demo() {
            const step3Panel = document.getElementById('step3-panel');
            const step3ChatBody = document.getElementById('step3-chatbody');
            const step3ChatInput = document.getElementById('step3-chatinput');
            const step3ChatSend = document.getElementById('step3-chatsend');
            const step3Cursor = document.getElementById('step3-cursor');

            // Show panel
            step3Panel.classList.add('visible');

            await wait(600);

            // Show "Thinking..."
            const thinkingMsg = document.createElement('div');
            thinkingMsg.className = 'tg-msg tg-ai';
            thinkingMsg.innerHTML = '<div class="tg-ai__content thinking">Thinking...</div>';
            step3ChatBody.appendChild(thinkingMsg);

            await wait(1200);

            // Remove thinking, add first AI response
            thinkingMsg.remove();

            const aiMsg1 = document.createElement('div');
            aiMsg1.className = 'tg-msg tg-ai';
            aiMsg1.innerHTML = '<div class="tg-ai__content"></div>';
            step3ChatBody.appendChild(aiMsg1);

            const response1 = 'Artificial intelligence (AI) in this context refers to the development of computer systems that can perform tasks typically requiring human intelligence, such as learning and problem-solving. It encompasses various approaches, including machine learning, which specifically focuses on algorithms that allow systems to learn from data and improve over time without being explicitly programmed for each scenario. This relationship highlights AI\'s broader goal of creating systems that can autonomously adapt and enhance their performance, marking a significant evolution from traditional programming methods.';

            // Typewriter effect
            const aiContent1 = aiMsg1.querySelector('.tg-ai__content');
            for (let i = 0; i <= response1.length; i++) {
                aiContent1.textContent = response1.substring(0, i);
                step3ChatBody.scrollTop = step3ChatBody.scrollHeight;
                await wait(15);
            }

            await wait(800);

            // Move cursor to input box
            const inputRect = step3ChatInput.getBoundingClientRect();
            const inputX = inputRect.left + 40;
            const inputY = inputRect.top + inputRect.height / 2;

            step3Cursor.querySelector('img').src = 'images/cursor.png';
            step3Cursor.style.left = inputX + 'px';
            step3Cursor.style.top = inputY + 'px';
            step3Cursor.style.display = 'block';
            step3Cursor.style.opacity = '1';

            await wait(400);

            // Click input
            await wait(100);

            // Hide cursor, type question
            step3Cursor.style.opacity = '0';

            await wait(200);

            const question = "What are neural networks?";
            step3ChatInput.value = '';

            for (let i = 0; i <= question.length; i++) {
                step3ChatInput.value = question.substring(0, i);
                await wait(80);
            }

            await wait(400);

            // Move cursor to send button
            const sendRect = step3ChatSend.getBoundingClientRect();
            const sendX = sendRect.left + sendRect.width / 2;
            const sendY = sendRect.top + sendRect.height / 2;

            step3Cursor.style.left = sendX + 'px';
            step3Cursor.style.top = sendY + 'px';
            step3Cursor.style.opacity = '1';

            await wait(600);

            // Click send
            step3ChatSend.style.transform = 'translateY(-50%) scale(0.95)';
            await wait(100);
            step3ChatSend.style.transform = '';

            step3Cursor.style.opacity = '0';
            await wait(200);
            step3Cursor.style.display = 'none';

            // Clear input and add user message
            step3ChatInput.value = '';

            const userMsg = document.createElement('div');
            userMsg.className = 'tg-msg tg-user';
            userMsg.innerHTML = '<div class="tg-user__bubble">What are neural networks?</div>';
            step3ChatBody.appendChild(userMsg);
            step3ChatBody.scrollTop = step3ChatBody.scrollHeight;

            await wait(400);

            // Show "Thinking..." again
            const thinkingMsg2 = document.createElement('div');
            thinkingMsg2.className = 'tg-msg tg-ai';
            thinkingMsg2.innerHTML = '<div class="tg-ai__content thinking">Thinking...</div>';
            step3ChatBody.appendChild(thinkingMsg2);
            step3ChatBody.scrollTop = step3ChatBody.scrollHeight;

            await wait(1200);

            // Remove thinking, add second AI response
            thinkingMsg2.remove();

            const aiMsg2 = document.createElement('div');
            aiMsg2.className = 'tg-msg tg-ai';
            aiMsg2.innerHTML = '<div class="tg-ai__content"></div>';
            step3ChatBody.appendChild(aiMsg2);

            const response2 = 'Neural networks are computational models inspired by the biological neural networks found in human brains. They consist of interconnected layers of artificial neurons that process information. Each neuron receives input, applies a mathematical transformation, and passes the output to the next layer.\n\nA typical neural network is structured in layers:\n\nInput Layer: This layer receives the initial data.\n\nHidden Layers: These layers perform various transformations on the input data. Each neuron in a hidden layer computes a weighted sum of its inputs and applies an activation function, often represented as:\n\nz = w₁x₁ + w₂x₂ + … + wₙxₙ + b\n\nwhere wᵢ are the weights, xᵢ are the inputs, and b is the bias. The output of the neuron is then calculated using an activation function f(z):\n\na = f(z)\n\nOutput Layer: This layer produces the final output of the network, which can represent classifications, predictions, or other results depending on the task.\n\nNeural networks are particularly powerful for tasks like image recognition, natural language processing, and other applications requiring complex pattern recognition. The training process involves adjusting the weights and biases to minimize the difference between the predicted output and the actual output, often using techniques like backpropagation and gradient descent.';

            // Typewriter effect with paragraph support
            const aiContent2 = aiMsg2.querySelector('.tg-ai__content');
            const paragraphs = response2.split('\n\n');

            for (let p = 0; p < paragraphs.length; p++) {
                if (p > 0) {
                    aiContent2.innerHTML += '<p></p>';
                }

                const para = paragraphs[p];
                const currentP = aiContent2.lastElementChild || aiContent2;

                for (let i = 0; i <= para.length; i++) {
                    if (currentP.tagName === 'P') {
                        currentP.textContent = para.substring(0, i);
                    } else {
                        currentP.textContent = para.substring(0, i);
                    }
                    step3ChatBody.scrollTop = step3ChatBody.scrollHeight;
                    await wait(10);
                }
            }

            await wait(1000);

            // Demo complete - old functions kept for compatibility
        }
    </script>
</body>
</html>
